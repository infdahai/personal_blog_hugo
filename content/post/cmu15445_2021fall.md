---
title: "Cmu15445_2021fall"
date: 2022-05-28T17:34:10+08:00
draft: false
author: "clundro"
tags: ["database"]
categories: ["C++", "database"]

weight: 10
contentCopyright: MIT
mathjax: true
autoCollapseToc: true

---


## Lecture 01


## Proj 0

完成矩阵计算。

```cpp
 Matrix(int rows, int cols) : rows_(rows), cols_(cols), linear_{new T[rows * cols]} {}

  RowMatrix(int rows, int cols) : Matrix<T>(rows, cols) {
    data_ = new T *[rows];
    for (int i = 0; i < rows; i++) {
      data_[i] = this->linear_ + i * cols;
    }
  }

  void FillFrom(const std::vector<T> &source) override {
    // throw NotImplementedException{"RowMatrix::FillFrom() not implemented."};
    bool flag = source.size() == static_cast<size_t>(this->rows_ * this->cols_);
    if (!flag) {
      throw Exception{ExceptionType::OUT_OF_RANGE, "out_of_range"};
    }
    memcpy(this->linear_, &source[0], source.size() * sizeof(T));
  }

    static std::unique_ptr<RowMatrix<T>> Multiply(const RowMatrix<T> *matrixA, const RowMatrix<T> *matrixB) {
    // TODO(P0): Add implementation
    int k{};
    bool flag = ((k = matrixB->GetRowCount()) == matrixA->GetColumnCount());
    if (!flag) {
      return std::unique_ptr<RowMatrix<T>>(nullptr);
    }

    int a{matrixA->GetRowCount()};
    int b{matrixB->GetColumnCount()};
    auto matrixC{std::make_unique<RowMatrix<T>>(a, b)};
    for (int i = 0; i < a; i++) {
      for (int j = 0; j < b; j++) {
        T sum{};
        for (int t = 0; t < k; t++) {
          sum += matrixA->GetElement(i, t) * matrixB->GetElement(t, j);
        }
        matrixC->SetElement(i, j, sum);
      }
    }
    return matrixC;
  }

```

比较简单，就贴下代码。

## Proj 1: buffer pool

缓存区主要用于在内存和磁盘间移动物理页。

`unique_lock`可以更细粒度持有`mutex`，使用`unique.unlock()`释放锁，内部需要维持锁状态，因此也会更慢。而`lock_guard`则对象析构时如果持有锁会自动释放锁，所有权可以转移。对象生命期内允许手动加锁和释放锁。

题外话，自c++ 17之后，`scoped_lock` 是 `lock_guard`高级替代，严格基于作用域(scope-based)的锁管理类模板，构造时是否加锁是可选的(不加锁时假定当前线程已经获得锁的所有权)，析构时自动释放锁，所有权不可转移，对象生存期内不允许手动加锁和释放锁。

`LRUReplacer`最大`page num`等于`buffer pool`的大小，因为包含`BufferPoolManager` 所有`frame`的占位符。(逻辑地址的基本块单位是`page`，物理地址的基本块单位是`frame`)。初始情况，`LRUReplacer`没有`frame`。只有新`unpinned`的帧会放入。

```cpp
Victim(frame_id_t*)//从LRUReplacer去除最近最少访问的frame

Pin(frame_id_t)//
Unpin(frame_id_t)//
// pin是将page将固定到BufferPoolManager后调用的方法，
// 使得LRUReplacer中相应的frame移除。
// unpin会在page pagecount为0时调用。

Size()// frame num in LRUReplacer

// 由于Replacer根据id查找page，因此使用map。但因为lru的特性，使用list比较方便，同时用hash table记录位置。

//其中 unordered_map使用bucket实现，而非tree，因此可以reserve
```

`BufferPoolManagerInstance` 用于从`DiskManager`取到数据库`page`，并将其存储在内存中。当需要排出`page`时，也可以写回到磁盘（比如`dirty page`）。

当`Page`不包含物理页，`page_id`必须设置成`INVALID_PAGE_ID`。每个`Page`对象维护`pin`此页面的线程数量。`BufferPoolManagerInstance`不允许释放`Page that is pinned`。`Page`要维护`is_dirty`。


```cpp
Page *FetchPgImp(page_id)
//  从 buffer pool 维护的页表中根据page_id取出数据。

UnpinPgImp(page_id, is_dirty)
// 从 buffer pool unpin page,要写回数据。

FlushPgImp(page_id)
// 不管pin状态，直接写回磁盘。

NewPgImp(page_id)
// 在buffer pool 创新新页。

DeletePgImp(page_id)
//从 buffer pool 删除 page。

FlushAllPagesImpl()
//刷新所有 page。

```

`pin` 和 `unpin`对于`LRUReplacer`和`BufferPoolManager`是相反的含义（其实很好理解，这二者结构是数据互相传输的，这里固定即另一处解除固定）。
